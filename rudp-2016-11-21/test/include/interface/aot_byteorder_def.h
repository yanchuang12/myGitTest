#ifndef __AOT_BYTEORDER_DEF_H__
#define __AOT_BYTEORDER_DEF_H__

/* Byte ordering detection */  
#include <sys/types.h> /* This will likely define BYTE_ORDER */
#ifndef BYTE_ORDER  
#if (BSD >= 199103)  
# include <machine/endian.h>  
#else  
#if defined(linux) || defined(__linux__)  
# include <endian.h>  
#else  
#define LITTLE_ENDIAN   1234    /* least-significant byte first (vax, pc) */  
#define BIG_ENDIAN  4321    /* most-significant byte first (IBM, net) */  
#define PDP_ENDIAN  3412    /* LSB first in word, MSW first in long (pdp)*/  

#if defined (i386) || defined(__i386__) || defined(__x86_64__) || defined(__amd64__) || defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || defined(_MIPSEL) || defined(BIT_ZERO_ON_RIGHT) || defined(__alpha__) || defined(__alpha)  
#define BYTE_ORDER    LITTLE_ENDIAN  
#endif  

#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || defined(MIPSEB) || defined(_MIPSEB) || defined(_IBMR2) || defined(DGUX) || defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(__hppa) || defined(__hp9000) || defined(__hp9000s300) || defined(__hp9000s700) || defined (BIT_ZERO_ON_LEFT) || defined(m68k) || defined(__sparc)  
#define BYTE_ORDER  BIG_ENDIAN  
#endif  
#endif /* linux */  
#endif /* BSD */  
#endif /* BYTE_ORDER */  

/* Sometimes after including an OS-specific header that defines the 
* endianess we end with __BYTE_ORDER but not with BYTE_ORDER that is what 
* the Redis code uses. In this case let's define everything without the 
* underscores. */  
#ifndef BYTE_ORDER  
#ifdef __BYTE_ORDER  
#if defined(__LITTLE_ENDIAN) && defined(__BIG_ENDIAN)  
#ifndef LITTLE_ENDIAN  
#define LITTLE_ENDIAN __LITTLE_ENDIAN  
#endif  
#ifndef BIG_ENDIAN  
#define BIG_ENDIAN __BIG_ENDIAN  
#endif  
#if (__BYTE_ORDER == __LITTLE_ENDIAN)  
#define BYTE_ORDER LITTLE_ENDIAN  
#else  
#define BYTE_ORDER BIG_ENDIAN  
#endif  
#endif  
#endif  
#endif  

#if !defined(BYTE_ORDER) || (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)  
/* you must determine what the correct bit order is for 
* your compiler - the next line is an intentional error 
* which will force your compiles to bomb until you fix 
* the above macros. 
*/  
#error "Undefined or invalid BYTE_ORDER"  
#endif  

/*
__inline unsigned long long ntohll(unsigned long long val)
{
	if (__BYTE_ORDER == __LITTLE_ENDIAN)
	{
		return (((unsigned long long )htonl((int)((val << 32) >> 32))) << 32) | (unsigned int)htonl((int)(val >> 32));
	}
	else if (__BYTE_ORDER == __BIG_ENDIAN)
	{
		return val;
	}
}

__inline unsigned long long htonll(unsigned long long val)
{
	if (__BYTE_ORDER == __LITTLE_ENDIAN)
	{
		return (((unsigned long long )htonl((int)((val << 32) >> 32))) << 32) | (unsigned int)htonl((int)(val >> 32));
	}
	else if (__BYTE_ORDER == __BIG_ENDIAN)
	{
		return val;
	}
}
*/
#endif /// __AOT_BYTEORDER_DEF_H__